def solution(scores):
    answer = 0
    # 잘 생각해보니 인덱스를 저장하고 말고 할 게 없다.
    # 먼저 점수 하나를 기준으로 내림차순 정렬 한다. 그 이후 다른 점수로 오름차순 정렬을 한다.
    # 그러면 맨 앞에는 점수 하나가 가장 높고 그 가장 높은 점수를 가진 그룹 중에서
    # 두 번째 점수가 가장 낮은 사람이 존재하게 된다.
    # 이제 이 사람보다 두 번째 점수가 낮은 모든 사람은 전부 탈락시킨다.
    # 두 번째 점수 기준 내림차순 이므로 첫 번째 점수가 같은 그룹 내에서는 누가 탈락할 일이 없다.
    # 두 번째 점수가 현재의 기준보다 작은 사람이 발견된다면
    # 어차피 첫 번째 점수는 낮을게 자명하기 때문에 인사고과에서 탈락이기 때문이다.
    # 이렇게 걸렀으면 그 다음으로 두 번째 점수가 큰 사람으로 넘어가거나 첫 번째 점수가 더 작고 
    # 두 번째 점수는 앞사람보다 큰 사람으로 넘어가게 된다. 다시 이 사람이 기준이 되어 나머지를 거른다.
    # 실제로 거를 필요는 없고 순위를 셀 때 건너뛰면 될 것 같다.
    
    wanho_score = scores[0]
    
    sorted_scores = sorted(scores, key=lambda x:(-x[0],x[1]))
    
    standard = 0 # 첫 기준 점수는 가장 낮은 점수인 0점으로 한다. 이후 앞에서부터 하나 씩 기준을 늘려간다.
    for score in sorted_scores:
        if wanho_score[0] < score[0] and wanho_score[1] < score[1]:
            # 완호의 점수가 특정 사람의 점수보다 둘 다 낮은 경우를 발견하면 바로 -1을 리턴
            return -1
        if standard <= score[1]:
            # 기준 점수를 업데이트 하는 로직이다.
            if wanho_score[0] + wanho_score[1] < score[0] + score[1]:
                # 일단 여기까지 들어왔다는 것은 기준 점수를 넘겼다는 뜻(최소한 점수 하나라도 이전 사람보다 같거나 크다)이므로
                # 완호와 비교한다. 완호보다 크다면 완호의 순위를 뒤로 미룬다.
                answer += 1
            standard = score[1]
            
    return answer+1
